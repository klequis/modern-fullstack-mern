# Inserting One Document

Add `insertOne` to `db/dbFunctions.js`

```js
/**
 * 
 * @param {string} collection the name of a collection
 * @param {object} data a documnet, without _id, to be inserted
 */
export const insertOne = async (collection, data) => {
  try {
    const { db } = await connectDB()
    const ret = await db.collection(collection).insertOne(data)
    return formatReturnSuccess(ret.ops[0])
  }
  catch (e) {
    console.error('ERROR: dbFunctions.insertOne', e)
    return formatReturnError(e)
  }
}
```

Add `insertOne` to exports in `db/index.js`

__db/index.js__
```js
export { 
  dropCollection,
  insertOne // added
} from './dbFunctions'
```

Add `insertOne` to imports in `dbFunctions.test.js`
```js
import { 
  dropCollection,
  insertOne // added
} from 'db'
```

## Return Value

`insertOne` returns a large object of which only a small part is needed for our purposes. Here is a shortened version of the returned object.

```js
{
  result: { n: 1, ok: 1 },
  connection:
   Connection {
     _events: { ... }
     id: 0,
     options: { ... }
     logger: Logger { className: 'Connection' },
     bson: BSON {},
     tag: undefined,
     maxBsonMessageSize: 67108864,
     port: 27017,
     host: 'localhost',
     socketTimeout: 360000,
     keepAlive: true,
     keepAliveInitialDelay: 300000,
     connectionTimeout: 30000,
     responseOptions: { ... }
     flushing: false,
     queue: [],
     writeStream: null,
     destroyed: false,
     hashedName: '29bafad3b32b11dc7ce934204952515ea5984b3c',
     workItems: [],
     socket: { ... }
     buffer: null,
     sizeOfMessage: 0,
     bytesRead: 0,
     stubBuffer: null,
     ismaster: { ... }
  message: { ... }
  ops: [ { title: 'todo added', _id: 5ce2a7d9d1d0cc3ae9f545fc } ],
  insertedCount: 1,
  insertedId: 5ce2a7d9d1d0cc3ae9f545fc
}
```

The part that will be returned is:
```js
ops: [ { title: 'todo added', _id: 5ce2a7d9d1d0cc3ae9f545fc } ]
```

## Testing `insertOne`

Since this is the first test to be written, we need to do a little setup of the `dbFunctions.test.js` module

__test/dbFunctions.test.js__
```js
import { expect } from 'chai'
import { fourTodos } from './fixture'
import { 
  dropCollection,
  insertOne // added
} from 'db'
```

Now we can write the test

```js
describe('test insertOne', function() {
  before(async function() {
    await dropCollection(collectionName)
    await insertMany(collectionName, fourTodos)
  })
  // insertOne will only be used for new todos.
  // for new todos, competed is always false and set by the server
  const newData = { title: 'todo added' }
  it('insertOne: should insert new document', async function() {
    const i = await insertOne(collectionName, newData)
    expect(i.data._id).to.be.not.null
    expect(i.data.title).to.equal('todo added')
  })
})
```