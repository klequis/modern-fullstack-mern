# ZZ Testing Find

There is a bit of a chicken and egg problem with writing the first test. The database must be cleaned-up and then prepopulated before functions that act on the data can be used. To clean-up and prepopulation, functions that are not tested yet must be used. As a result, rather than putting setup in a `before` hook, the setup will be done inside of tests.

The functions used in this group of test are `close` `dropCollection`, `find` & `insertMany`. `dropCollection`. `close`, which is part of clean-up, will not have a test. You will know if close fails if the server fails to shutdown.<sup>(1)</sup>

## Imports
We import `expect` from chai, `fourTodos` from the fixture and the three functions mentioned above from `db/dbFunctions.js`. The test code goes into `test/dbFunctions.test.js`.

```js
// dbFunctions.test.js
import { expect } from "chai"
import { fourTodos } from "./fixture"
import {
  close,
  dropCollection,
  find,
  insertMany
} from "../../db"
```

A root-level `after` is used to call `close` on the database once all the tests are completed. This allows the server to shutdown after test completion.

```js
// dbFunctions.test.js
...

after( async () => {
  await close()
})
```

Start with a `describe` block with the label 'dbFunctions'

```js
// dbFunctions.test.js
...

describe('dbFunctions', () => {

})
```

Before running any tests we want a clean/empty database to start with so that when the test run we know exactly what is in it. to do this use `dropCollection`. `dropCollection` will return ...
```js
 { data: true, error: '' }
```
... if the call is successful

> NOTE: It is a bit untypical to clean-up before rather than after the test run. However, I sometimes find it useful to see what is in the database after the tests have completed, so am doing clean-up before the tests run.


```js
// dbfunctions.test.js
...

describe('test dropCollection', function() {
  it('dropCollection: should return true', async function() {
    const drop = await dropCollection('todos')
    expect(drop.data).to.be.true
  })
})

...
```

> Use `console.log()` often. For example, you can check the return value of `dropCollection` like this:
> ```
> console.log('d', d)
> ```

This the database needs to be prepopulated using `insertMany`. Since the test data inserted has 4 todos, the test will check that an 4 elements were inserted. Using console.log('d', d) following the call to `insertMany` returns:

```console
{
   data: {
     result: { ok: 1, n: 4 },
     ops: [ [Object], [Object], [Object], [Object] ],
     insertedCount: 4,
     insertedIds: {
       '0': 5cc9f3cb5498d8389941cec4,
       '1': 5cc9f3cb5498d8389941cec5,
       '2': 5cc9f3cb5498d8389941cec6,
       '3': 5cc9f3cb5498d8389941cec7
     }
   },
   error: ''
}
```

Given this result, we can test for `data.result.n === 4`


```js
// dbFunctions.test.js
...

describe('test insertMany', function() {
  it('insertMany: should insert 4 todos', async function() {
    const i = await insertMany('todos', fourTodos)
    expect(i.data.result.n).to.equal(4)
  })
})

...
```

`find` should also return an array of four elements. The return value of `find` is:
```console
{
    data: [
        {
          _id: 5cc9f676323b3539a3603ed3,

          title: 'first todo',
          completed: false
        },
        {

            _id: 5cc9f676323b3539a3603ed4,

            title: 'second todo',

            completed: false
        },
        {
            _id: 5cc9f676323b3539a3603ed5,
            title: 'third todo',
            completed: false
        },
        {
            _id: 5cc9f676323b3539a3603ed6,
            title: 'fourth todo',
            completed: false
        }
    ],
    error: ''
}
```
Given this result we can test that `data.length === 4`

```js
// dbFunctions.test.js
...

describe('test find', function() {
  it('find: should return 4 todos', async function() {
    const f = await find('todos')
    console.log('f', f);

    expect(f.data.length).to.equal(4)
  })
})

...
```

Here is the complete module.
```js
// dbFunctions.test.js

import { expect } from 'chai'
import { fourTodos } from './fixture'
import {
  close,
  dropCollection,
  find,
  findById,
  insertMany
} from '../../db'

after( async () => {
  await close()
})

describe('dbFunctions', () => {
  // describe('test find', function() {
  describe('test dropCollection', function() {
    it('dropCollection: should return true', async function() {
      const drop = await dropCollection('todos')
      expect(drop.data).to.be.true
    })
  })
  describe('test insertMany', function() {
    it('insertMany: should insert 4 todos', async function() {
      const i = await insertMany('todos', fourTodos)
      expect(i.data.result.n).to.equal(4)
    })
  })
  describe('test find', function() {
    it('find: should return 4 todos', async function() {
      const f = await find('todos')
      console.log('f', f);

      expect(f.data.length).to.equal(4)
    })
  })
})
```


# Notes
1. To see the effect of close not working comment out the call to close and run the tests.
```js
after( async () => {
  // await close()
})
```
When the have completed you will not be returned to the command prompt. Press <kbd>ctl-c</kbd> to do so.
