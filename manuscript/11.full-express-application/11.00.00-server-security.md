# [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/), RisingStack

## HTTP Headers



### [ContentSecurity Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

- Protect against XSS
  - Specify domains that the browser should consider valid sources of executible scripts.
- Mitigating packet sniffing attacks
  - Specify allowed protocols
    - HTTPS


# OWASP


## JS Injection
- Don't use eval
- Do use "use strict"

## SQL & NoSQL Injection
- SQL
  - Use prepared statements
  - Validate inputs for malicious values
  - Validate input types against expected types
  - Use 'least privilege' for DB and OS accounts
  - Don't create ad-hoc queries by concatinate script with user input


- NoSQL - all of the above +
  - Don't allow user/app account to query existance of collections

## MongoDB `$where`
  - `$where` operator performs JS expression evaluation on the MongoDB server leaving it open to injected code.

### References
- [Server-Side JavaScript Injection](https://media.blackhat.com/bh-us-11/Sullivan/BH_US_11_Sullivan_Server_Side_WP.pdf), Bryan Sullivan, Senior Security Researcher, Adobe Secure Software Engineering Team, July 2011


## Log Injection
Attacker tries to forge and tamper application logs

### Mediation
- Turn off logging to console in production
- Don't put user input into logs
- Encode input to context or sanitize

**Encoding example**
```js
// Step 1: Require a module that supports encoding
var ESAPI = require('node-esapi');
// - Step 2: Encode the user input that will be logged in the correct context
// following are a few examples:
console.log('Error: attempt to login with invalid user: %s', ESAPI.encoder().encodeForHTML(userName));
console.log('Error: attempt to login with invalid user: %s', ESAPI.encoder().encodeForJavaScript(userName));
console.log('Error: attempt to login with invalid user: %s', ESAPI.encoder().encodeForURL(userName));
```

## Authentication and Session Management 

You must protect
- session id
- user credential
- secure storage
- session duration
- critical session data in transit

### Mitigation

- User authentication credentials should be protected when stored using hashing or encryption.
- Session IDs should not be exposed in the URL (e.g., URL rewriting).
- Session IDs should timeout. User sessions or authentication tokens should get properly invalidated during logout.
- Session IDs should be recreated after successful login.
- Passwords, session IDs, and other credentials should not be sent over unencrypted connections.

If using cookies, set properties on cookie:
- httpOnly: true
- secure: true

When user logs cout, destroy the session & cookie

### Session hijacking
Best practice is to regenerate the session id render older sessions invalid

**Ansower: Not using sessions.**

## Password Guessing Attacks
- Password at least 8 characters long
- Complexity including alpha, number, punctuation or other symbols
- Failed password and failed username/email should return **exactly the same response**.
- Disable repeated failed attempts in given time period
- Temporary passwords
  - Enforce password change after temporary pwd is issued
  - Temporary passwords and links should have short expiration time.

**Example password regex**
```js
var PASS_RE =/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/;
```

## Cross Site Scripting (XSS) 
XSS allows attackers to execute scripts in the victim's browser.

### Mitigation
- Input validation & sanitization: Use white list.
- Output encoding for correct context: ...
- ...
The rest of this is at http://localhost:4000/tutorial/a3. Since my app will strip out all tags this doesn't need to be otherwise addressed.

## Insecure Direct Object References (DOR)
- Possible when reference to resource is exposed without access control check or *other protection*.

| The demo is amazing. The user id is on the end of the uri and is '3', changing to '4' gets a different users data - amazing!

### Mitigation
- Officuate references. If you have resources r-abc & r-bcd send them to the client as (eg) r-732 & r-985 and keep a map of the values on the server.
- Don't take/use the user id from the url, get it from the session
  - My app doesn't have a session :( However, userIds are GUIDS and cannot be guessed. In addition, a token must be sent.

## Misconfig


### Mitigation
- Use latest stable version of node.js and express (or other web framework you are using). Keep a watch on published vulnerabilities of these. The vulnerabilities for node.js and express.js can be found here and here, respectively.
- Do not run application with root privileges. It may seem necessary to run as root user to access privileged ports such as 80. However, this can achieved either by starting server as root and then downgrading the non-privileged user after listening on port 80 is established, or using a separate proxy, or using port mapping.
- Review default in HTTP Response headers to prevent internal implementation disclosure.
- Use generic session cookie names
- Limit HTTP Request Body size by setting sensible size limits on each content type specific middleware ( urlencoded, json, multipart) instead of using aggregate limitmiddleware. Include only required middleware. For example if application doesn't need to support file uploads, do not include multipart middleware.
- If using multipart middleware, have a strategy to clean up temporary files generated by it. These files are not garbage collected by default, and an attacker can fill disk with such temporary files
- Vet npm packages used by the application
- Lock versions of all npm packages used, for example using shrinkwarp, to have full control over when to install a new version of the package.
Set security specific HTTP headers

#### Recommended Helmet settings
It is recommended to use Helmet

```js
// Prevent opening page in frame or iframe to protect from clickjacking
app.disable("x-powered-by");

// Prevent opening page in frame or iframe to protect from clickjacking
app.use(helmet.xframe());

// Prevents browser from caching and storing page
app.use(helmet.noCache());

// Allow loading resources only from white-listed domains
app.use(helmet.csp());

// Allow communication only on HTTPS
app.use(helmet.hsts());

// Forces browser to only use the Content-Type set in the response header instead of sniffing or guessing it
app.use(nosniff());
```

## Sensitive Data Exposure

### Mitigation
- Use Secure HTTPS network protocol
- Encrypt all sensitive data at rest and in transit
  - At rest in this case means the database
- Donâ€™t store sensitive data unnecessarily. Discard it as soon as possible.
- Ensure strong standard algorithms and strong keys are used, and proper key management is in place.
- Disable autocomplete on forms collecting sensitive data and disable caching for pages that contain sensitive data.

## Access Controls
- Need to check access control on each request to the server.

The demo shows a non-admin user changing the url from /dashboard to /benefits and access granted. Only an admin should be able to access /benefits.

| I have this one covered

## Cross-Site Request Forgery (CSRF)
Someone creates a fake form and targets the user site with it.
The colution is to us a scrftoken. However, it should be put in a hidden  form which would require that we also controlled the client which we don't.

## Insecure Components
Is about npm packages and other libraries.
### Mitigation
- Only use well-known and tested npm packages
- Review packages for unexpected file or database access
- Lock versions of packages
- Stay tuned to npm security notices

## Unvalidated Redirects and Forwards
- Avoid doing redirects and forwards - got that
- If used, don't make use of user input 
- If you have to use user data, insure that the dated is valid and from authorized user

## Regular Expressions DoS (ReDoS)
- Avoid writing your own regular expressions
- Use Node.js's validator.js package to validate expected data format instead of writing your own regular expressions
- As a last resort of writing your own regex patterns you can utilize Node.js's safe-regex package which allows detecting if a regex is prone to catastrophic backtracking, and also allows to configure threshold for maximum repetitions.

## Server-Side Request Forgery (SSRF)
- Use a whitelist of allowed domains, resources and protocols from where the web server can fetch resources.
- Any input accepted from the user should be validated and rejected if it does not match the positive specification expected.
- If possible, do not accept user input in functions that control where the web server can fetch resources.

Not doing anything like this so not a problem









---
---

# Seven Web Server HTTP Headers that Improve Web Application Security for Free

## X-Content-Type-Options
- If set to 'nosniff' it stops the browser from guessing MIME type.
### Secure configuration 
- Server returns the 'X-Content-Type-Options' HTTP header set to 'nosniff'.


## X-XSS-Protection
- Set to 'mode=block' to enable IE 8 & higher to enable its inbuilt anti-cross-site scripting filter.
### Secure configuration
- Server returns the 'X-XSS-Protection' HTTP header set to '1; mode=block'.


## X-Frame-Options
- Used to indicate whether or not a browser should be allowed to render a page withoin a `<frame>` or `<iframe>`.
### Secure configuration
- Server returns the 'X-Frame-Options' HTTP header set to 'DENY' or 'SAMEORIGIN'.


## Cache-Control
- Controls how pages can be cached either by proxies or the user's browser.
- Set to 'no-store' for sensitive pages.
### Secure configuration
- Either the server sets a cache control by returning the 'Cache-Control' HTTP header set to `no-store, no-cache` or each page sets their own via the 'meta' tag for secure connections.

| Note that `no-store, no-cache` is AND, not OR


## X-Content-Security-Policy
- Used to control which sites certain content types can be loaded from.
| My take on this is it isn't appropriate for an open API as you don't known where the request will be coming from.


## Strict-Transport-Security
- Control if the browser is allowed to only access a site over a secure connection and how long to remember the server response for thus forcing continued usage.
### Secure configuration
Return the 'Strict-Transport-Security' header with an appropriate timeout over an secure connection.


## Access-Control-Allow-Origin
- Control which sites are allowed to bypass same origin policies and send cross-origin requests.
**I set this to '*'**

## Reference
- [ Seven Web Server HTTP Headers that Improve Web Application Security for Free
](http://recxltd.blogspot.com/2012/03/seven-web-server-http-headers-that.html)

