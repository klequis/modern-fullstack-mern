# (01) Introduction

**para-1.1**
This is a book with lots of step by step instructions for doing things but not too much explanation of what they are nor ... (something). After all, all of that is out on the internet already. Taking all that information filtering it into a cohesive set of technologies for a given project and then fitting it all together is harder to come by.

**para-1.2**
This is a book about putting it all together with detailed step-by-step instructions and plenty of links to lead you to in-depth material.

**para-1.3**
One upon a time software developers went to book stores to find new knowledge and documentation can packaged with purchased sofware that was distributed on CDs. Books ... more or less complete, begining to end on a subject. These days, documentation is online, books still live but ... but much/most information scattered across the internet in ... doc ... blogs ... snippets of code.

This book brings it together.

**para-1.4**

(maybe this can go at the beginning of the introduction as a way of leading into what the book covers and how it is structured)

I would include everything in this book if only:
- I had time to write it
- You had time to read it
- I actually knew everthing


**para-1.5**
This book is a step by step learning experience. Following the steps in the book you will build a full-stack web application with ...... The learning experience is links to related content. You read the content to learn, the book will guide you through building the application.

**para-1.6**

This is not a book about React, Express, MongoDB or NodeJS. Those are four very large subjects that are entire books of their own. This is a book on how to build and deploy a web application with those technologies and is repleat with explanations and references to learning materials. The best way to make use of this book is to read the referenced materials as you go though the book. Alternatively, and maybe a bit more fun, you could build the app first and then go back and read through the reference materials. Either way, when done you will have learnedd a lot and built a full-stack web application.


**I could**
I could draw a diagram that illustrates all the parts of the stack but it would be overly complex and not useful.


## There is a lot of good documentation out there
Not only are React, Express, MongoDB and NodeJS large subjects, there is already great learning material available. What I think less common and what this book addresses, is how to put it all together.

- put this section later. It makes little sense to copy thing from a manual into the book, although that what is often done. The benefit of the book is you can spend a lot of time figuring out what information you need
- addresses 'what you need to do'
- addresses 'where to find the information'
- provides step by step
- and a little prespective - 3 cheers

> I really recommend reading the documentation. It is pretty time consuming but it will make you much better at what you do. They never show it in the movies, but developers spend quite a bit of time reading documentation.


## A very simple UI
- there is a lot to cover
- the UI will be simple. it will cover the goal of talking to the back end and touch on the basics of all the technologies that make-up the client side stack. Going deep could make the overally book too long and cumbersome to be useful.
- Many references to additional information are included so you can go deeper into each subject.

## Who is this book for?
This is an intermediate to advanced level book. Readers should have a firm grasp of JavaScript and a basic understanding of React, Express, Node & MongoDB. The book it more implementation than concept focused.

## Testing
Given the amount of time needed to write this book vs the amount of time I have, I decided early on to not focus on testing for fear of turning the project of writing this book into something larger than I would be able to complete. That said, automated tests are essential to making good software.

## Code Editor
The client application will be using TypeScript. For the server, using TypeScript types from [DefinitelyTyped](http://definitelytyped.org/) as well as types that are built into libraries makes coding significantly easier. While you can use any editor you prefer, [Visual Studio Code](https://code.visualstudio.com/) is referenced by some of the examples and in my opinion, is the best free choice for using TypeScript.

## Mac, Linux & Windows
I work exclusively on Linux (Ubuntu 18.04). As a result, everything in the book will work on Mac and Linux. There are some difference in configuration for getting things to work on Windows. However, due to time constraints I will not be including that information.

## Give Ubuntu (Linux) a Try
For those not familiar with Linux I'll mention that doing software development on Linux is a genuine pleasure and a great learning experience that will help you in the server world. In fact, the Express server build in this book will run on Ubuntu, a variation of Linux. I highly recommend giving Ubuntu a try as you everyday development machine.

Spinning up a Linux virtual machine is an easy thing to do and a good learning experience in itself. In my experience with running a Linux VM on Windows, you need about 8 GB RAM. More is better. If you are short of RAM you can dual boot your system.

## Async/Await
The code will use async/await. If you are not familiar with them, under the covers they are promises, but have a better syntax. A good reference for learning to use async/await is XXXXX.

## Perferences
Software development is full of preferences and from choice of code editor to libraries used, this book very much reflects mine. My preferences may not be any better than someone elses. They may even be worse. However, they have been working well for me in terms of productivity, flexability and robustness.

## Choice: DigitalOcean
I like the price and, even before I started using them for hosting, many of my Google Linux questions landed on DigitalOcean's well writting Linux guides.

## Choice: AWS S3
Again, I like the price of hosting on AWS S3. Deploying a React application to S3 is also very easy. I currently have about 6 sites hosted there.

## Choice: AWS Route 53

## Choice: Not putting the client on the same server (i.e., DigitalOcean droplet) as the server (i.e., todo-server)
> bla, bla, bla ... do I need to address this
I have another demo app deployed with both the client and server hosted on a DigitalOcean droplet. This works well and is only costing about $5 per month. However, note it is a demo app and is built with the lowest priced/configuration droplet. A production app would require a higher level of resources.

## Choice: `cross-fetch`
- [axios](https://www.npmjs.com/package/axios) is a bood choice but its usage differs significantly from `fetch` itself.
- [isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch) hasen't been updated in 3 years.
- [fetch]() ? why not use? isn't cross platform?

## Choice: Container components

Dan's original article [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
[Twitter Consation](https://twitter.com/IslamAttrash/status/1056128899229331456)
I have been using Container & Presentation components for a long time now. With the emergence of hooks in react and react-redux it seems more common to eliminate the container and distrubite the redux connectivity to where it is used.
I really didn't like this before I tried it, but given the level of discussion around it I decided to give it a try. So far I'm quite happy and decided to use this approach for the book.
My guess there will be cases where a container component still makes sense but I haven't run into it yet (or not in this book).
