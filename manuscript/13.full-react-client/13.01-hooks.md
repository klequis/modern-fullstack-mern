> TODO: I got a surprise working with the client after adding validation to the server. The validation doesn't require a connection to mongodb so a validation error is still returned when mongodb isn't running. Makes sense but unanticipated.


- Stateless components are now called 'function components'
- Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.
  - From: https://reactjs.org/docs/hooks-effect.html
- Effect clean-up (the function returned from the effect) is run when the component unmounts and after(before?) each render

- useState is siilar to this.setState in a class, except it doens't merge the old and the new state together.

- It is currently recommended to use hooks for fetching data. However, at some future date the will change when a feature named Suspense is introduced. (Is it also stated somewhere by Facebook that using Hooks today will make moving to Suspense for data fetching easier in the future?)

- Hooks are a way to reuse stateful logic, not the state itself.



## Key Points

### Previous state

The previous state is passed to the set function. E.g.,

```js
const [count, setCount] = useState(initialCount);
...
<button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
```

### State is not merged

Hooks do not merged state objects. You need to implement this yourself. One way to do this is:

```js
setState(prevState => {
  // Object.assign would also work
  return {...prevState, ...updatedValues};
});
```

Another way is `useReducer` which is a better option form more complex state objects.

### Initial state can be a function

```js
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```



### Linting
- eslint-plugin-react-hooks
