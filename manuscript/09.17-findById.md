# Find by ID

<!-- To test `findById` we will setup the database by prepopulating it with todos from our test data and then compare one of the ids of the prepopulated todos to the one retrieved via `findById` The test is added to `dbFunctions.test.js`. -->


> TODO: This page was written prior to standardizing the format for dbFunctions & dbFunctions.test.js. It needs a through review. Some of its content may be incorrect and/or not needed.

Add `findById` to `db/dbFunctions.js`

```js
/**
 * 
 * @param {string} collection the name of a collection
 * @param {string} id a valid _id as string
 * @param {object} project a valid projection
 */
export const findById = async (collection, id, project = {}) => {
  try {
    const { db } = await connectDB()
    const ret = await db.collection(collection).find({ _id: ObjectID(id) }).project(project).toArray()
    return formatReturnSuccess(ret)
  }
  catch (e) {
    logError('findById', e)
    return formatReturnError(e)
  }
}
```

Add `findById` to exports in `db/index.js`
```js
export { 
  ...
  find,
  findById, // added
  insertMany,
  ...
} from './dbFunctions'
```

Add `findById` to imports in `test/dbFunctions.test.js`.

```js
import { 
  ...
  find,
  findById, // added
  insertMany,
  ...
} from 'db'
```

> TODO: Review the below

Since the functions needed to setup the database have already been tested, setup will be done inside a `before` hook. Inside of the hook we need to:
- drop the 'todos' collection to start with a fresh database
- populate test data with `inserMany`
- save the id of the second todo returned in `idToFind`
- call `findById` passing to it `idToFind`
- confirm the id of the todo returned from `findById` matches the one in `idToFind`

> Since MongoDB ids come back as objects and two `_id` objects will never equal each other. The object ids must be converted to strings in order to be compared.<sup>(1)</sup>

> TODO: end review


# Return Value
```js
[ { _id: 5ce2cd6e9851d7613e16b178,
    title: 'first todo',
    completed: false } ]
```



Now we are ready for the `findById` test. The steps are:
- retrieve the todo with the `_id` saved above in `findById`
- check that one todo was returned
- get the `_id` of the returned todo and convert it to a string
- check that the `_id` of the returned todo matches the `_id` in `idToFind`

## Test findById

```js
// dbFunctions.test.js

describe('test findById', function() {
  let idToFind = undefined
  before(async function() {
    await dropCollection(collectionName)
    const inserted = await insertMany(collectionName, fourTodos)
    idToFind = inserted.data[0]._id.toString()
  })
  it('findById: should return 1 todo with id of second todo', async function() {
    const f = await findById('todos', idToFind)
    expect(f.data.length).to.equal(1)
    const idFound = f.data[0]._id.toString()
    expect(idFound).to.equal(idToFind)
  })
})
```



## Why are two objects with the same value(s) not equal to each other?
JavaScript, and programming languages in general have 'primitive types' and 'reference types'. Primitive types are values in memory. Object types are 'references' (aka pointers or addresses) of an object in memory.

When comparing two objects, JavaScript compares the references. Therefore:
```js
const a = { name: 'joe' }
const b = a
console.log(a === b) // true - they are the same object and therefore the same references
const c = { name: 'joe' }
console.log(a === c) // false - a & c are two different objects.
```
