# Find by ID

<!-- To test `findById` we will setup the database by prepopulating it with todos from our test data and then compare one of the ids of the prepopulated todos to the one retrieved via `findById` The test is added to `dbFunctions.test.js`. -->


> TODO: This page was written prior to standardizing the format for dbFunctions & dbFunctions.test.js. It needs a through review. Some of its content may be incorrect and/or not needed.

Add `findById` to `db/dbFunctions.js`

```js
/**
 * 
 * @param {string} collection the name of a collection
 * @param {string} id a valid _id as string
 * @param {object} project a valid projection
 */
export const findById = async (collection, id, project = {}) => {
  try {
    const { db } = await connectDB()
    const ret = await db.collection(collection).find({ _id: ObjectID(id) }).project(project).toArray()
    return formatReturnSuccess(ret)
  }
  catch (e) {
    return formatReturnError('findById', e)
  }
}
```

Add `findById` to exports in `db/index.js`
```js
export {
  close,
  dropCollection,
  find,
  findById, // added
  insertMany,
  insertOne
} from './dbFunctions'
```

Add `findById` to imports in `test/dbFunctions.test.js`.

```js
import { 
  close,
  dropCollection,
  find,
  findById, // added
  insertMany,
  insertOne,
} from 'db'
```


# Return Value
```js
[ { _id: 5ce2cd6e9851d7613e16b178,
    title: 'first todo',
    completed: false } ]
```



Now we are ready for the `findById` test. The steps are:
- retrieve the todo with the `_id` saved above in `findById`
- check that one todo was returned
- get the `_id` of the returned todo and convert it to a string
- check that the `_id` of the returned todo matches the `_id` in `idToFind`

## Test findById

Testing `findById` is slightly more complex than the previous tests. Here is what we will do:

Setup
- Drop the `todos` collection.
- Insert 4 todos.
- Save the `_id` of the first document in the variable `idToFind`.

Test
- Call `findById` passing the `_id` in `idToFind`.
- Check that only 1 document is returned.
- Check that the `_id` of the returned document matches the `_id` in `idToFind`

> Note that MongoDB _ids come back as objects and therefore two `_id` objects will never equal each other. The object ids must be converted to strings in order to be compared.<sup>(1)</sup>

```js
// dbFunctions.test.js

describe('test findById', function() {
  let idToFind = undefined
  before(async function() {
    await dropCollection(collectionName)
    const inserted = await insertMany(collectionName, fourTodos)
    idToFind = inserted.data[0]._id.toString()
  })
  it('findById: should return 1 todo with id of second todo', async function() {
    const f = await findById('todos', idToFind)
    expect(f.data.length).to.equal(1)
    const idFound = f.data[0]._id.toString()
    expect(idFound).to.equal(idToFind)
  })
})
```



## Why are two objects with the same value(s) not equal to each other?
JavaScript, and programming languages in general have 'primitive types' and 'reference types'. Primitive types are values in memory. Object types are 'references' (aka pointers or addresses) of an object in memory.

When comparing two objects, JavaScript compares the references. Therefore:
```js
const a = { name: 'joe' }
const b = a
console.log(a === b) // true - they are the same object and therefore the same references
const c = { name: 'joe' }
console.log(a === c) // false - a & c are two different objects.
```
