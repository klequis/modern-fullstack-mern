# ZZ The Remaining Tests

Now that we have gone through several tests in detail, I'll proceed through the remainder of the tests more quickly.

Make sure the 3 additional functions are imported
```js
import {
  close,
  dropCollection,
  find,
  findById,
  findOneAndDelete, // added
  insertOne, // added
  insertMany,
  findOneAndUpdate // added
} from '../../db'
...
```
## findOneAndDelete

The test will check that the `_id` of the returned document matches the `_id` we used when calling `findOneAndDelete`. If `findOneAndDelete` has failed, a document will not be returned

```js
// dbFunctions.test.js

describe('test findOneAndDelete', function() {
  let idToDelete = undefined
  before(async function() {
    await dropCollection('todos')
    const i = await insertMany('todos', fourTodos)
    idToDelete = i.data[1]._id.toString()
    
  })
  it('findOneAndDelete: should delete 1 of 4 todos', async function() {
    const d = await findOneAndDelete('todos', idToDelete)
    const idDeleted = d.data._id.toString()
    expect(idDeleted).to.equal(idToDelete)
    
  })
})
...
```

## findOneAndUpdate

Since we have written `findOneAndUpdate` to have `returnOriginal = false` the returned value will be the updated document. Check that the _id is the same and that values in the updated document match the new data sent.


```js
// dbFunctions.test.js

describe('test findOneAndUpdate', function() {
  const newData = { title: 'changed title', completed: true }
  let idToUpdate = undefined
  before(async function() {
    await dropCollection('todos')
    const i = await insertMany('todos', fourTodos)
    idToUpdate = i.data[1]._id.toString()
  })
  it('findOneAndUpdate: should return updated document', async function() {
    const u = await findOneAndUpdate('todos', idToUpdate, newData)
    expect(u.data._id.toString()).to.equal(idToUpdate)
    expect(u.data.title).to.equal(newData.title)
    expect(u.data.completed).to.equal(newData.completed)
  })
})
...
```

## insertOne

Check that the document returned has a non-null _id and that its title is the one we sent.

```js
// dbFunctions.test.js

describe('test insertOne', function() {
  // insertOne will only be used for new todos.
  // for new todos, competed is always false and set by the server
  const newData = { title: 'todo added' }
  it('insertOne: should insert new document', async function() {
    const i = await insertOne('todos', newData )
    expect(i.data._id).to.be.not.null
    expect(i.data.title).to.equal('todo added')
  })
})
```

That's it! All your tests should be passing now. Here is the completed module

```js
// dbFunctions.test.js

import { expect } from 'chai'
import { fourTodos } from './fixture'
import {
  close,
  dropCollection,
  find,
  findById,
  findOneAndDelete,
  insertOne,
  insertMany,
  findOneAndUpdate
} from '../../db'

after( async () => {
  await close()
})

describe('dbFunctions', () => {
  // describe('test find', function() {
  describe('test dropCollection', function() {
    it('dropCollection: should return true', async function() {
      const drop = await dropCollection('todos')
      expect(drop.data).to.be.true
    })
  })
  describe('test insertMany', function() {
    it('insertMany: should insert 4 todos', async function() {
      const i = await insertMany('todos', fourTodos)
      expect(i.data.length).to.equal(4)
    })
  })
  describe('test find', function() {
    it('find: should return 4 todos', async function() {
      const f = await find('todos')
      expect(f.data.length).to.equal(4)
    })
  })
    
  describe('test findById', function() {
    let idToFind = undefined
    before(async function() {
      await dropCollection('todos')
      const i = await insertMany('todos', fourTodos)
      idToFind = i.data[0]._id.toString()
    })
    it('findById: should return 1 todo with id of second todo', async function() {
      const f = await findById('todos', idToFind)
      expect(f.data.length).to.equal(1)
      const idFound = f.data[0]._id.toString()
      expect(idFound).to.equal(idToFind)
    })
  })

  describe('test findOneAndDelete', function() {
    let idToDelete = undefined
    before(async function() {
      await dropCollection('todos')
      const i = await insertMany('todos', fourTodos)
      idToDelete = i.data[1]._id.toString()
      
    })
    it('findOneAndDelete: should delete 1 of 4 todos', async function() {
      const d = await findOneAndDelete('todos', idToDelete)
      const idDeleted = d.data._id.toString()
      expect(idDeleted).to.equal(idToDelete)
      
    })
  })

  describe('test findOneAndUpdate', function() {
    const newData = { title: 'changed title', completed: true }
    let idToUpdate = undefined
    before(async function() {
      await dropCollection('todos')
      const i = await insertMany('todos', fourTodos)
      idToUpdate = i.data[1]._id.toString()
    })
    it('findOneAndUpdate: should return updated document', async function() {
      const u = await findOneAndUpdate('todos', idToUpdate, newData)
      expect(u.data._id.toString()).to.equal(idToUpdate)
      expect(u.data.title).to.equal(newData.title)
      expect(u.data.completed).to.equal(newData.completed)
    })
  })

  describe('test insertOne', function() {
    // insertOne will only be used for new todos.
    // for new todos, competed is always false and set by the server
    const newData = { title: 'todo added' }
    it('insertOne: should insert new document', async function() {
      const i = await insertOne('todos', newData )
      expect(i.data._id).to.be.not.null
      expect(i.data.title).to.equal('todo added')
    })
  })

})

```