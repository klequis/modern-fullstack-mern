<!-- To test `findById` we will setup the database by prepopulating it with todos from our test data and then compare one of the ids of the prepopulated todos to the one retrieved via `findById` The test is added to `dbFunctions.test.js`. -->



Add `findById` to imports.



```js
import {
  close,
  dropCollection,
  find,
  findById, // findById added
  insertMany
} from '../../db'
```

Since the functions needed to setup the database have already been tested, setup will be done inside a `before` hook. Inside of the hook we need to:
- drop the 'todos' collection to start with a fresh database
- populate test data with `inserMany`
- save the id of the second todo returned in `idToFind`
- call `findById` passing to it `idToFind`
- confirm the id of the todo returned from `findById` matches the one in `idToFind`

> Since MongoDB ids come back as objects and two `_id` objects will never equal each other. The object ids must be converted to strings in order to be compared.<sup>(1)</sup>

```js
// dbFunctions.test.js

let idToFind = undefined // variable to store _id in

before(async function() {
  await dropCollection('todos')
  const i = await insertMany('todos', fourTodos)
  idToFind = i.data.insertedIds[1].toString() // get 2nd _id and convert to string
})
```

Now we are ready for the `findById` test. The steps are:
- retrieve the todo with the `_id` saved above in `findById`
- check that one todo was returned
- get the `_id` of the returned todo and convert it to a string
- check that the `_id` of the returned todo matches the `_id` in `idToFind`


```js
// dbFunctions.test.js

it('findById: should return 1 todo with id of second todo', async function() {
  const f = await findById('todos', idToFind)
  expect(f.data.length).to.equal(1)
  const idFound = f.data[0]._id.toString()
  expect(idFound).to.equal(idToFind)
})
```

Run the tests
```console
$ npm test
```

Here is the complete module:

```js
// dbFunctions.test.js

import { expect } from 'chai'
import { fourTodos } from './fixture'
import {
  close,
  dropCollection,
  find,
  findById,
  insertMany
} from '../../db'

after( async () => {
  await close()
})

describe('dbFunctions', () => {
  // describe('test find', function() {
  describe('test dropCollection', function() {
    it('dropCollection: should return true', async function() {
      const drop = await dropCollection('todos')
      expect(drop.data).to.be.true
    })
  })
  describe('test insertMany', function() {
    it('insertMany: should insert 4 todos', async function() {
      const i = await insertMany('todos', fourTodos)
      expect(i.data.result.n).to.equal(4)
    })
  })
  describe('test find', function() {
    it('find: should return 4 todos', async function() {
      const f = await find('todos')
      console.log('f', f);

      expect(f.data.length).to.equal(4)
    })
  })

  describe('test findById', function() {
    let idToFind = undefined
    before(async function() {
      await dropCollection('todos')
      const i = await insertMany('todos', fourTodos)
      idToFind = i.data.insertedIds[1].toString()
    })
    it('findById: should return 1 todo with id of second todo', async function() {
      const f = await findById('todos', idToFind)
      expect(f.data.length).to.equal(1)
      const idFound = f.data[0]._id.toString()
      expect(idFound).to.equal(idToFind)
    })
  })
})

```

## Why are two objects with the same value(s) not equal to each other?
JavaScript, and programming languages in general have 'primitive types' and 'reference types'. Primitive types are values in memory. Object types are 'references' (aka pointers or addresses) of an object in memory.

When comparing two objects, JavaScript compares the references. Therefore:
```js
const a = { name: 'joe' }
const b = a
console.log(a === b) // true - they are the same object and therefore the same references
const c = { name: 'joe' }
console.log(a === c) // false - a & c are two different objects.
```
