??? What is this ???
Is it still needed?

The first thing we are going to do is create wrappers to some of the MongoDB native driver's functions. Writing these functions, along with a small helper library and standardizing the way that data and errors are returned to the client will, make our code much more understandable and easier to maintain.

- About MongoDB queries
- Shaping data
- New project
- Install packages
- Create /db
- Create dbFunctions.js, helpers.js & index.js
- Import mongodb
- Store reference to MongoClient
- Connection details
- Connection management
- Returning errors
- Returning data
- Implementing `find()`
- Write tests



> TODO: what libs install, what they do and why. Maybe just links to save room and error?


# Start the project
```js
$ mkdir wrapping-calls-to-mongodb
$ cd wrapping-calls-to-mongodb
$ npm init -y
$ npm i mongodb @babel/runtime chalk ramda
$ npm i -D @babel/cli @babel/core @babel/node @babel/plugin-transform-runtime @babel/preset-env chai eslint eslint-plugin-import mocha nodemon supertest
```

## Project structure
```js
$ mkdir db
$ cd db
$ touch dbFunctions.js helpers.js index.js
cd ..
mkdir server
touch server/index.js
touch .babelrc .gitignore
mkdir config
touch config/index.js
```

## config/index.js
```js

const mongoUrl = (env) => {
  if (env === 'test') {
    return 'mongodb://localhost:27017'
  }
  return 'mongodb+srv://todo-db-admin:D92dARWONO0t16uF@todo-cluster0-ilc7v.mongodb.net/test?retryWrites=true'
}

const dbName = (env) => {
  if (env === 'test') {
    return 'todo-test'
  } else if (env === 'dev') {
    return 'todo-dev'
  }
  return 'todo-prod'
}

const apiRoot = (env)  => {
  if (env === 'prod') {
    return ''
  }
  return 'https://api.klequis-todo.tk'
}

export default {
  mongoUrl: mongoUrl(process.env.NODE_ENV),
  dbName: dbName(process.env.NODE_ENV),
  apiRoot: apiRoot(process.env.NODE_ENV),
  port: 3030
};

```


## .gitignore
```js
dist
node_modules
coverage
logs
log
*.log
app.log.*
npm-debug.log*
pids
*.pid
*.seed
lib-cov
.lock-wscript
.npm
.node_repl_history
.nyc_output
```

## .babelrc
```js
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    "@babel/plugin-transform-runtime",
  ]
}
```

## db/helpers.js
```js
import { ObjectID } from  'mongodb'
import { omit } from 'ramda'

export const objectIdFromHexString = async (hexId) => {
  try {
    return await ObjectID.createFromHexString(hexId)
  }
  catch (e) {
    console.error('ERROR /db/helpers.js.objectidFromHexString', e)
  }
}

export const getObjectId = async (id) => {
  if (ObjectID.isValid(id)) {
    const objId = await objectIdFromHexString(id)

    return objId
  } else {
    throw new Error('ERROR /db/helpers.js.getObjectId', e)
  }
}

export const removeIdProp = (obj) => {
  return omit(['_id'], obj)
}
```

## db/dbFunctions.js



All our calls to MongoDB will be done through functions in dbFunctions.js. Start by importing mongodb and getting a reference to the MongoClient.


> TODO: these notes were in the code. Put them back?
> A reference to the client will be stored in the `client` variable and reused each time a call needs to be made. The `connectDB` function will make the connection to the client if it isn't already made, and then return a reference to the database.
> `formatReturn` will be used after each call to MongoDB to standardize the way that messages are sent back to the client.


```js
import mongodb, { ObjectID } from 'mongodb'
import { removeIdProp } from './helpers'
import config from '../config'

const MongoClient = mongodb.MongoClient

let client

export const connectDB = async () => {
  if (!client) {
    client = await MongoClient.connect(config.mongoUrl, { useNewUrlParser: true })
  }
  return { db: client.db(config.dbName) }
}

export const close = async ()  => {
  if (client) {
    client.close()
  }
  client = undefined
}

const formatReturnSuccess = (data)  => {
  return { data: data, error: '' }
}

const formatReturnError = (error)  => {
  return { data: [], error: error.message }
}

const logError = (functionName, error)  => {
  console.error(`Error: dbFunctions.${functionName}`, error.message)
}

```

The `dropCollection` function takes one parameter, a collection name

```js
/**
 *
 * @param {string} collection the name of a collection
 */
export const dropCollection = async (collection) => {
  try {
    const { db } = await connectDB()
    const ret = await db.collection(collection).drop()
    return formatReturnSuccess(ret)
  }
  catch (e) {
    if (e.message = 'ns not found') {
      return true
    } else {
      logError('dropCollection', e)
      return formatReturnError(e)
    }
  }
}
```

The `find` function takes between 1 and 3 parameters

| Parameter | Type | Comment |
| --------- | ---- | ------- |
| `connection` | string | The collection name as a string. In our case 'todo-dev' |
| `filter` | object | A valid MongoDB query object. The default is `{}` which returns all documents in a collection.|
| `projection` | object | A valid MongoDB projection. The default is `{}` which will return all fields. |

- Queries are like filters. They limit the documents that are sent back
- In this case, the projection is a list of fields

The body of `find` is in a try/catch block so that formatReturn is called in the event of any type of error and the return value is in the correct shape.

```js
/**
 *
 * @param {string} collection the name of a collection
 */
export const find = async (collection, filter = {}, project = {}) => {
  try {
    const { db } = await connectDB()
    const ret = await db.collection(collection).find(query).project(project).toArray()
    return { data: ret, meta: {} }
  }
  catch (e) {
    console.error('ERROR: dbFunctions.find', e.message)
    return formatReturn(e)
  }
}
```

## db/index.js
```js
import {
  find
} from './dbFunctions'

export {
  find
}
```

## server/index.js
```js
import { find } from './db'

async function findTest() {
  const todos = await find('todos')
  console.log('todos', todos)
}

findTest()
```

## Add start script in package.json
```js
"start": "babel-node server/index.js"
```

## Give it a try
```js
$ npm start
```


In the next section we will write some test for the `fined` function.
